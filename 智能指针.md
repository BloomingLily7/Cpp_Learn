# 智能指针

## 1.引言

C++ 引入智能指针的主要目的是为了**自动化内存管理**，减少手动 `new` 和 `delete` 带来的复杂性和错误.

在对象生命周期结束时自动释放资源，从而有效防止内存泄漏和资源管理错误.

## 2.原生指针 vs 智能指针

### 原生指针

原生指针存在以下问题：

- **内存泄漏**：未释放动态分配的内存。

  ```c++
  #include <iostream>
  
  void createMemoryLeak() {
      // 在堆上分配内存但从不释放
      int* leakedMemory = new int[100];  // 分配100个int的空间
      
      // 这里使用了分配的内存...
      leakedMemory[0] = 42;
      std::cout << "Value: " << leakedMemory[0] << std::endl;
      
      // 函数结束，指针leakedMemory超出作用域被销毁，
      // 但没有调用delete[]释放内存，导致内存泄漏
  }
  
  int main() {
      createMemoryLeak();
      
      // 现在无法访问或释放createMemoryLeak()中分配的内存
      // 程序每次运行createMemoryLeak()都会泄漏100*sizeof(int)字节
      
      return 0;
  }
  ```

- **悬挂指针**：指针指向已释放或未初始化的内存。

  ```c++
  #include <iostream>
  
  int main() {
      int* ptr = new int(100);  // 动态分配内存
      
      delete ptr;  // 释放内存
      
      // ptr现在是一个悬挂指针，因为它指向的内存已被释放
      *ptr = 50;  // 危险！未定义行为
      
      std::cout << *ptr << std::endl;  // 可能输出垃圾值或导致程序崩溃
      
      return 0;
  }
  ```

- **双重释放**：多次释放同一内存区域。

  ```c++
  #include <iostream>
  
  int main() {
      int* ptr = new int(100);  // 动态分配内存
  
      // 第一次释放
      delete ptr;  
      std::cout << "第一次释放成功" << std::endl;
  
      // 第二次释放 - 危险！双重释放
      delete ptr;  
      std::cout << "第二次释放成功" << std::endl;  // 可能不会执行到这里
  
      return 0;
  }
  ```

### 智能指针的优势

智能指针通过封装原生指针，自动管理内存，解决上述问题。主要优势包括：

- **自动销毁**：在智能指针生命周期结束时自动释放资源。
- **引用计数**：共享智能指针能够跟踪引用数量，确保资源在最后一个引用结束时释放。
- **避免内存泄漏**：通过 RAII（资源获取即初始化） 机制自动管理资源生命周期。
- **类型安全**：提供更严格的类型检查，减少错误。

## 3.std::unique_ptr

### 定义

一种**独占所有权**的智能指针，任何时刻**只能有一个** `unique_ptr` 实例拥有对某个对象的所有权。**不能被拷贝，只能被移动**。

**主要特性**：

- **独占所有权**：确保资源在一个所有者下。
- **轻量级**：没有引用计数，开销小。
- **自动释放**：在指针销毁时自动释放资源

### 用法

```c++
#include <iostream>
#include <memory>

class Test {
public:
    Test(int val) : value(val) {
        std::cout << "Test Constructor: " << value << std::endl;
    }
    ~Test() {
        std::cout << "Test Destructor: " << value << std::endl;
    }
    void show() const {
        std::cout << "Value: " << value << std::endl;
    }

private:
    int value;
};

int main() {
    // 创建一个 unique_ptr
    std::unique_ptr<Test> ptr1(new Test(100));
    ptr1->show();

    // 使用 make_unique（C++14 引入）
    auto ptr2 = std::make_unique<Test>(200);
    ptr2->show();

    // 移动 unique_ptr
    std::unique_ptr<Test> ptr3 = std::move(ptr1);
    if (!ptr1) {
        std::cout << "ptr1 is now nullptr after move." << std::endl;
    }
    ptr3->show();

    // 重置 unique_ptr
    ptr2.reset(new Test(300));
    ptr2->show();

    // unique_ptr 自动释放资源
    return 0;
}
```

## 4.std::shared_ptr

### 定义

`std::shared_ptr` 是一种共享所有权的智能指针，允许多个 `shared_ptr` 实例共享对同一个对象的所有权。通过引用计数机制，管理资源的生命周期。

**主要特性**：

- **共享所有权**：多个 `shared_ptr` 可以指向同一个对象。
- **引用计数**：跟踪有多少 `shared_ptr` 实例指向同一对象。
- **自动释放**：当引用计数为0时，自动释放资源。

### 用法

```c++
#include <iostream>
#include <memory>

class Test {
public:
    Test(int val) : value(val) {
        std::cout << "Test Constructor: " << value << std::endl;
    }
    ~Test() {
        std::cout << "Test Destructor: " << value << std::endl;
    }
    void show() const {
        std::cout << "Value: " << value << std::endl;
    }

private:
    int value;
};

int main() {
    // 创建一个 shared_ptr
    std::shared_ptr<Test> sp1(new Test(100));
    std::cout << "sp1 use_count: " << sp1.use_count() << std::endl;
    sp1->show();

    // 通过拷贝构造共享所有权
    std::shared_ptr<Test> sp2 = sp1;
    std::cout << "After sp2 = sp1:" << std::endl;
    std::cout << "sp1 use_count: " << sp1.use_count() << std::endl;
    std::cout << "sp2 use_count: " << sp2.use_count() << std::endl;

    // 通过拷贝赋值共享所有权
    std::shared_ptr<Test> sp3;
    sp3 = sp2;
    std::cout << "After sp3 = sp2:" << std::endl;
    std::cout << "sp1 use_count: " << sp1.use_count() << std::endl;
    std::cout << "sp2 use_count: " << sp2.use_count() << std::endl;
    std::cout << "sp3 use_count: " << sp3.use_count() << std::endl;

    // 重置 shared_ptr
    sp2.reset(new Test(200));
    std::cout << "After sp2.reset(new Test(200)):" << std::endl;
    std::cout << "sp1 use_count: " << sp1.use_count() << std::endl;
    std::cout << "sp2 use_count: " << sp2.use_count() << std::endl;
    std::cout << "sp3 use_count: " << sp3.use_count() << std::endl;
    sp2->show();

    // 自动释放资源
    std::cout << "Exiting main..." << std::endl;
    return 0;
}
```



## 5.std::weak_ptr

